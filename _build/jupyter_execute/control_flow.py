# Control Flow

## Условные выражения

Иногда вам нужно запустить (или не запускать) данный блок кода в зависимости от того, выполняются ли определенные условия. В этом случае условные выражения - ваш союзник. Эти операторы управляют выполнением группы операторов на основе значения истинности выражения. Вы можете создать условный оператор в Python с ключевым словом `if` и следующим общим синтаксисом:

```Python
if expr0:
    # Run if expr0 is true
    # Your code goes here...
elif expr1:
    # Run if expr1 is true
    # Your code goes here...
elif expr2:
    # Run if expr2 is true
    # Your code goes here...
...
else:
    # Run if all expressions are false
    # Your code goes here...

# Next statement
```

Оператор `if` запускает только один блок кода. Другими словами, если `expr0` истинно, будет выполняться только связанный с ним блок кода. После этого выполнение переходит к оператору непосредственно под оператором `if`.

Первое предложение `elif` оценивает `expr1` только в том случае, если `expr0` ложно. Если `expr0` - `False`, а `expr1` - `True`, то будет выполняться только блок кода, связанный с `expr1`, и так далее. Предложение `else` является необязательным и будет выполняться только в том случае, если все ранее оцененные условия ложны. У вас может быть столько предложений `elif`, сколько вам нужно, включая ни одного, но у вас может быть только одно предложение `else`.

Вот несколько примеров того, как это работает:

age = 21
if age >= 18:
    print("Вы совершеннолетний")

age = 16
if age >= 18:
    print("Вы совершеннолетний")
else:
    print("Вы НЕсовершеннолетний")

age = 18
if age > 18:
    print("Вы старше 18 лет")
elif age == 18:
    print("Вам ровно 18 лет")

В первом примере возраст равен `21`, поэтому условие истинно, и Python выводит на экран «Вы совершеннолетний». Во втором примере выражение `age >= 18` оценивается как `False`, поэтому Python запускает блок кода предложения `else` и печатает на экране «Вы НЕсовершеннолетний».

В последнем примере первое выражение `age > 18` ложно, поэтому выполнение переходит к предложению `elif`. Условие в этом предложении истинно, поэтому Python запускает связанный блок кода и печатает «Вам ровно 18 лет».


### Тернарный оператор

Синтаксис тернарного оператора:

```Python
<expr1> if <conditional_expr> else <expr2>
```

Он отличается от оператора `if`, потому что это не структура управления, которая направляет поток выполнения программы. Он действует больше как оператор, определяющий выражение. В приведенном выше примере сначала вычисляется `<conditional_expr>`. Если это правда, выражение оценивается как `<expr1>`. Если это ложь, выражение оценивается как `<expr2>`.

Обратите внимание на неочевидный порядок: сначала вычисляется среднее выражение, и на основе этого результата возвращается одно из выражений на концах. Вот несколько примеров, которые, надеюсь, помогут прояснить ситуацию:

raining = False
print("Let's go to the", 'beach' if not raining else 'library')

raining = True
print("Let's go to the", 'beach' if not raining else 'library')

age = 12
'minor' if age < 21 else 'adult'

'yes' if ('qux' in ['foo', 'bar', 'baz']) else 'no'

```{note}
Условное выражение Python похоже на `<conditional_expr> ? <expr1> : синтаксис <expr2>`, используемый многими другими языками, включая C, Perl и Java.

Вы можете видеть в PEP 308, что `<conditional_expr> ? <expr1> : синтаксис <expr2>` рассматривался для Python, но в конечном итоге был отклонен в пользу синтаксиса, показанного выше.
```

Условные выражения также используют вычисление по сокращённой схеме. Части условного выражения не вычисляются, если в этом нет необходимости.

В выражении `<expr1> if <conditional_expr> else <expr2>`:

* Если `<conditional_expr>` истинно, возвращается `<expr1>`, а `<expr2>` не вычисляется.
* Если `<conditional_expr>` ложно, возвращается `<expr2>`, а `<expr1>` не вычисляется.

Вы можете проверить это, используя выражения, которые могут вызвать ошибку:

'foo' if True else 1/0

1/0 if False else 'bar'

В обоих случаях `1/0` не вычисляется, поэтому исключение не возникает.

## Циклы

Если вам нужно повторить фрагмент кода несколько раз, чтобы получить окончательный результат, вам может потребоваться цикл. Циклы - это распространенный способ многократного повторения и выполнения определенных действий на каждой итерации. Python предоставляет два типа циклов:


* циклы `for` для определенной итерации или выполнения заданного числа повторений
* циклы `while` для неопределенной итерации или повторение до тех пор, пока не будет выполнено заданное условие

### Цикл for

```Python
for loop_var in iterable:
    # Этот блок кода повторяется до тех пор, пока iterable не будет закончен
    # Делаем что-нибудь с loop_var...
    if break_condition:
        break  # Выйти из цикла
    if continue_condition:
        continue  # Продолжить цикл без выполнения оставшегося кода
    # Оставшийся код...

# Следующее выражение
```

Этот тип цикла выполняет столько итераций, сколько элементов в `iterable`. Обычно вы используете каждую итерацию для выполнения операции над значением `loop_var`. Операторы `break` и `continue` являются необязательными.

for i in (1, 2, 3, 4, 5):
    print(i)
else:
    print("The loop wasn't interrupted")

Когда цикл обрабатывает последнее число в кортеже, поток выполнения переходит в предложение `else` и печатает *«The loop wasn't interrupted»*. Это потому, что ваш цикл не был прерван оператором `break`. Вы обычно используете предложение `else` в циклах, в блоке кода которых есть оператор `break`. В противном случае в этом нет необходимости.

#### break

Если в цикле встречается `break_condition`, то оператор `break` прерывает выполнение цикла и переходит к следующему оператору ниже цикла, не используя остальные элементы в итерации:

number = 3
for i in (1, 2, 3, 4, 5):
    if i == number:
        print("Number found:", i)
        break
else:
    print("Number not found")

Когда `i == 3`, цикл печатает *Number found: 3*, а затем выполняет `break`. Это прерывает цикл, и выполнение переходит к строке ниже цикла без выполнения предложения else. Если вы установите `number` равным `6` или любым другим числом, не входящим в набор чисел, то цикл не попадет в оператор `break` и напечатает *Number not found*.


#### continue

Если цикл достигает `continue_condition`, то оператор `continue` возобновляет цикл без выполнения кода в блоке цикла:

for i in (1, 2, 3, 4, 5):
    if i == 3:
        continue
    print(i)

На этот раз инструкция `continue` перезапускает цикл, когда `i == 3`. Вот почему вы не видите цифру `3` в выводе.

Оба оператора, `break` и `continue`, должны быть заключены в условное выражение. В противном случае цикл всегда прерывается, когда он выполняет `break`, и продолжается, когда он выполняет `continue`.

### Цикл while

Обычно цикл `while` используется, если заранее неизвестно, сколько итераций вам нужно для выполнения операции. Вот почему этот цикл используется для выполнения неопределенных итераций.

```Python
while expression:
    # Этот блок кода повторяется до тех пор, пока expression истинно
    # Делаем что-нибудь...
    if break_condition:
        break  # Выйти из цикла
    if continue_condition:
        continue  # Продолжить цикл без выполнения оставшегося кода
    # Оставшийся код...

# Следующее выражение
```

Этот цикл работает аналогично циклу `for`, но он будет повторяться до тех пор, пока выражение не станет ложным. Распространенная проблема с этим типом цикла возникает, когда вы предоставляете выражение, которое никогда не оценивается как `False`. В этом случае цикл будет повторяться бесконечно.

Вот пример того, как работает цикл `while`:

count = 1
while count < 5:
    print(count)
    count = count + 1
else:
    print("The loop wasn't interrupted")

Предложение `else` является необязательным, и его обычно используют с оператором `break` в блоке кода цикла. Здесь `break` и `continue` работают так же, как в цикле `for`.

Бывают ситуации, когда нужен бесконечный цикл. Например, приложения с графическим интерфейсом пользователя работают в бесконечном цикле, который управляет пользовательскими событиями. Этому циклу требуется оператор `break`, чтобы завершить цикл, когда, например, пользователь выходит из приложения. В противном случае приложение продолжало бы работать вечно.

## Обработка ошибок

### Исключения и синтаксические ошибки

Программа Python завершается, как только обнаруживает ошибку. В Python ошибка может быть **синтаксической ошибкой** или **исключением**.

Синтаксические ошибки возникают, когда парсер обнаруживает неверный оператор. Обратите внимание на следующий пример:


print( 0 / 0 ))

Стрелка указывает, где парсер обнаружил синтаксическую ошибку. В этом примере лишняя скобка. Удалите ее и снова запустите свой код:

print( 0 / 0 )

На этот раз вы столкнулись с ошибкой исключения. Этот тип ошибки возникает всякий раз, когда синтаксически правильный код Python приводит к ошибке. В последней строке сообщения указано, с каким типом ошибки исключения вы столкнулись.

Вместо того, чтобы показывать ошибку исключения сообщения, Python детализирует, какой тип ошибки исключения был обнаружен. В данном случае это была ошибка `ZeroDivisionError`. В Python существуют различные встроенные исключения, а также возможность создавать самоопределяемые исключения.

### Вызов исключения

Мы можем использовать вызов исключения, чтобы сгенерировать исключение при каком-то условии.

x = 10
if x > 5:
    raise Exception('x should not exceed 5. The value of x was: {}'.format(x))

Программа останавливается и отображает наше исключение на экране, предлагая подсказки о том, что пошло не так.

### Обработка исключений

#### try/except

Блок `try` и `except` в Python используется для перехвата и обработки исключений. Python выполняет код, следующий за оператором `try`, как «нормальную» часть программы. Код, следующий за оператором `except`, является ответом программы на любые исключения в предыдущем блоке `try`.

Как вы видели ранее, когда синтаксически правильный код сталкивается с ошибкой, Python выдает ошибку исключения. Эта ошибка исключения приведет к сбою программы, если она не будет обработана. Предложение `except` определяет, как ваша программа реагирует на исключения.

import sys
assert ('linux' in sys.platform), "Function can only run on Linux systems."

`'linux' in sys.platform` вернет True только в системе `Linux`. Если вы попытаетесь выполнить код в операционной системе, отличной от `Linux`, произойдет исключение `AssertionError`.

try:
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
except AssertionError as error:
    print(error)
    print('Linux function was not executed')

В коде выше мы обработали исключение. Если бы вы запустили этот код на машине с `Windows`, вы бы получили следующий результат: 

```Python
Function can only run on Linux systems.
Linux function was not executed
```

```{warning}
Перехват исключений скрывает все ошибки… даже совершенно неожиданные. Вот почему вам следует избегать голых исключений в ваших программах на Python. Вместо этого вам нужно обращаться к конкретным классам исключений, которые вы хотите перехватывать и обрабатывать.
```

* Предложение `try` выполняется до момента, когда встречается первое исключение.
* Внутри предложения `except` или обработчика исключения вы определяете, как программа реагирует на исключение.
* Вы можете предвидеть множественные исключения и различать, как программа должна на них реагировать.
* Избегайте использования заглушек в блоке `except`.

#### else

В Python с помощью оператора `else` вы можете указать программе выполнить определенный блок кода только при отсутствии исключений.

Взгляните на следующий пример:

try:
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
except AssertionError as error:
    print(error)
else:
    print('Executing the else clause.')

Если бы вы запустили этот код в системе `Linux`, результат был бы следующим:

```Python
Doing something.
Executing the else clause.
```

Поскольку программа не столкнулась с какими-либо исключениями, было выполнено предложение `else`.
Вы также можете попробовать запустить код внутри предложения `else` и отловить там возможные исключения:

try:
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)

Если бы вы выполнили этот код на машине `Linux`, вы бы получили следующий результат:

```Python
Doing something.
[Errno 2] No such file or directory: 'file.log'
```

Из выходных данных вы можете видеть, что первый блок `try` был запущен. Поскольку никаких исключений не обнаружено, была сделана попытка открыть `file.log`. Этот файл не существует, и вместо его открытия вы поймали исключение `FileNotFoundError`.

#### finally

Представьте, что вам всегда бы приходилось выполнять какое-то действие для очистки после выполнения вашего кода. Python позволяет сделать это с помощью предложения `finally`.

Взгляните на следующий пример:

try:
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)
finally:
    print('Cleaning up, irrespective of any exceptions.')

В коде выше всё, что указано в предложении finally, будет выполнено. Не имеет значения, встретите ли вы исключение где-нибудь в блоках `try` или `else`. 

Выполнение этого кода на компьютере с `Windows` приведет к следующему:

```Python
Function can only run on Linux systems.
Cleaning up, irrespective of any exceptions.
```