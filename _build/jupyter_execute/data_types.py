# Data Types

## Встроенные типы данных

Python имеет несколько встроенных типов данных, таких как **числа** (целые числа, числа с плавающей запятой, комплексные числа), **логические значения**, **строки**, **списки**, **кортежи**, **словари** и **множества**. Ими можно управлять с помощью нескольких инструментов:

* Операторы
* Встроенные функции
* Методы типа данных

### Числа

Python предоставляет **целые числа**, **числа с плавающей запятой** и **комплексные числа**. Целые числа и числа с плавающей запятой являются наиболее часто используемыми числовыми типами в повседневном программировании, в то время как комплексные числа имеют особые варианты использования в математике и естественных науках.

Вот краткое описание их функций:

|Number|Description|Examples|Python Data Type|
|:-----|:----:|----:|----:|
|Integer|Целые числа|1, 2, 42, 476, -99999|int|
|Floating-point|Числа с плавающей запятой|1.0, 2.2, 42.09, 476.1, -99999.9|float|
|Complex|Числа с действительной и мнимой частью|complex(1, 2), complex(-1, 7), complex("1+2j")|complex|

Целые числа имеют неограниченную точность. Информация о точности чисел с плавающей запятой доступна в `sys.float_info`. Комплексные числа имеют действительную и мнимую части, которые являются числами с плавающей запятой.

### Логические значения

Логические значения реализованы как подкласс целых чисел с двумя возможными значениями в Python: **True** или **False**. Обратите внимание, что эти значения должны начинаться с заглавной буквы.

### Строки

Строки - это фрагменты текста или последовательности символов, которые можно определить с помощью одинарных, двойных или тройных кавычек:

# Использование одинарных кавычек
greeting = 'Hello there!'

# Использование двойных кавычек
welcome = "Hello there!"

# Использование тройных кавычек
message = """Hello there!"""

# Экранирование символов
escaped = 'can\'t'
print('Escaped: ', escaped)

not_escaped = "can't"
print('Not escaped: ', not_escaped)

Обратите внимание, что вы можете использовать разные типы кавычек для создания строковых объектов в Python. Вы также можете использовать символ обратной косой черты (\) для экранирования символов со специальным значением, таких как сами кавычки.

### Списки

Списки обычно называются **массивами** почти во всех других языках программирования. В Python списки - это изменяемые последовательности, которые группируют различные объекты вместе. Чтобы создать список, вы используете присваивание с последовательностью объектов, разделенных запятыми, в квадратных скобках ([]) с правой стороны:

# Определение пустого списка
empty = []

# Определение списка чисел
numbers = [1, 2, 3, 100]

# Изменение списка
numbers[3] = 200

# Определение списка строк
superheroes = ["batman", "superman", "spiderman"]

# Определение списка объектов с разными типами данных
mixed_types = ["Hello World", [4, 5, 6], False]

Списки могут содержать объекты разных типов данных, в том числе другие списки. Они также могут быть пустыми. Поскольку списки являются изменяемыми последовательностями, вы можете изменять их на месте, используя индексную нотацию и операцию присваивания.

### Кортежи

Кортежи похожи на списки, но представляют собой неизменяемые последовательности. Это означает, что вы не можете изменить их после создания. Чтобы создать объект кортежа, можно использовать операцию присваивания с последовательностью элементов, разделенных запятыми, с правой стороны. Обычно для разделения кортежа используются круглые скобки, но они не являются обязательными:

employee = ("Jane", "Doe", 31, "Software Developer")

employee[0] = "John"

Если вы попытаетесь изменить кортеж на месте, вы получите ошибку TypeError, указывающую на то, что кортежи не поддерживают модификации.

### Словари

Словари - это тип ассоциативного массива, содержащего набор пар ключ-значение, в котором каждый ключ является хешируемым объектом, который сопоставляется с произвольным объектом, значением. Есть несколько способов создать словарь. Вот два из них:

person1 = {"name": "John Doe", "age": 25, "job": "Python Developer"}
person2 = dict(name="Jane Doe", age=24, job="Web Developer")

print(person1)
print(person2)

Первый подход использует пару фигурных скобок, в которые вы добавляете разделенный запятыми список пар ключ-значение, используя двоеточие (:) для отделения ключей от значений. Второй подход использует встроенную функцию `dict()`, которая может принимать аргументы ключевых слов и превращать их в словарь с ключевыми словами в качестве ключей и аргументами в качестве значений.

### Множества

Python также предоставляет такую структуру данных, как множество. Множества - это неупорядоченные и изменяемые коллекции произвольных, но хешируемых объектов Python. Создавать множества можно несколькими способами. Вот два из них:

employees1 = {"John", "Jane", "Linda"}

employees2 = set(["David", "Mark", "Marie"])

empty = set()

В первом примере для создания множества используются фигурные скобки и список объектов, разделенных запятыми. Если вы используете `set()`, вам необходимо предоставить итерацию с объектами, которые вы хотите включить в набор. Наконец, если вы хотите создать пустой набор, вам нужно использовать `set()` без аргументов. Использование пустой пары фигурных скобок создает пустой словарь вместо множества.

Один из наиболее распространенных вариантов использования множеств - их использование для удаления повторяющихся объектов из существующего итеративного объекта:

set ([1, 2, 2, 3, 4, 5, 3])

Поскольку наборы являются коллекциями уникальных объектов, когда вы создаете набор с помощью `set()` и итерируемого объекта в качестве аргумента, конструктор класса удаляет все повторяющиеся объекты и сохраняет только по одному экземпляру каждого из них в результирующем наборе.

Когда использовать словарь:
* Когда вам нужна логическая связь между парой key:value.
* Когда вам нужен быстрый поиск ваших данных на основе настраиваемого ключа.
* Когда ваши данные постоянно модифицируются. Помните, словари изменчивы.

Когда использовать другие типы:
* Используйте списки, если у вас есть набор данных, не требующий произвольного доступа. Старайтесь выбирать списки, когда вам нужна простая повторяющаяся коллекция, которая часто изменяется.
* Используйте множество, если вам нужна уникальность элементов.
* Используйте кортежи, когда ваши данные не могут измениться.

## Операции над числами

**Операторы** представляют такие операции, как сложение, вычитание, умножение, деление и т. д. Когда вы комбинируете их с числами, они образуют выражения, которые Python может вычислить:

```Python
# Сложение
5 + 3

# Вычитание
5 - 3

# Умножение
5 * 3

# Деление
5 / 3

# Целочисленное деление
5 // 3

# Остаток от деления
5 % 3

# Возведение в степень
5 ** 3
```

Эти операторы работают с двумя **операндами** и обычно называются **арифметическими операторами**. Операнды могут быть числами или переменными, которые содержат числа.

Передавая целое число или строку, представляющую число, `float()` возвращает число с плавающей запятой:


# Целые числа
float(9)

# Строки, представляющие числа
print(float("2"))
print(float("-200"))
print(float("2.25"))

# Комплексные числа
float(complex(1, 2))

С помощью `float()` вы можете преобразовывать целые числа и строки, представляющие числа, в числа с плавающей запятой, но вы не можете преобразовывать комплексное число в число с плавающей запятой.

Учитывая число с плавающей запятой или строку, `int()` возвращает целое число. Эта функция не округляет до ближайшего целого числа. Она просто обрезает, отбрасывая все, что находится после десятичной точки, и возвращает число. Итак, ввод 10,6 возвращает 10 вместо 11. Аналогично, 3,25 возвращает 3:


# Числа с плавающей запятой
int(10.6)

# Строки, представляющие числа
print(int("2"))
print(int("2.3"))

# Комплексные числа
int(complex(1, 2))

Обратите внимание, что вы можете передать строку, представляющую целое число, в `int()`, но вы не можете передать строку, представляющую число с плавающей запятой. Комплексные числа тоже не работают.


Помимо этих встроенных функций, с каждым типом числа связано несколько методов. Вы можете получить к ним доступ, используя ссылку на атрибут, также известную как точечная нотация (**dot notation**):


10.0.is_integer()

10.2.is_integer()

(10).bit_length()

10.bit_length()

Эти методы могут быть полезным инструментом для изучения. В случае целых чисел для доступа к их методам через литерал (**literal**) необходимо использовать пару круглых скобок. В противном случае вы получите SyntaxError.

## Логические выражения и операторы

Логические значения используются, чтобы выразить значение истинности выражения или объекта. Логические значения удобны при написании функций-предикатов или при использовании операторов сравнения, таких как больше (>), меньше (<), равно (==) ...


2 < 5

4 > 10

4 <= 3

3 >= 3

5 == 6

6 != 9

Python предоставляет встроенную функцию `bool()`, которая тесно связана с логическими значениями. Вот как это работает:

bool(0)

bool(1)

bool("")

bool("a")

bool([])

bool([1, 2, 3])

`bool()` принимает объект в качестве аргумента и возвращает True или False в соответствии с истинным значением объекта.

`int()` принимает логическое значение и возвращает 0 для False и 1 для True:

int(False)

int(True)

Это связано с тем, что Python реализует свои логические значения как подкласс `int`.

## Операции над строками

После определения строк можно использовать оператор «плюс» (+), чтобы объединить их в новую строку:


"Happy" + " " + "pythoning!"

При использовании со строками оператор «плюс» (+) объединяет их в одну строку. 
Обратите внимание, что вам нужно включить пробел (" ") между словами, чтобы иметь правильный интервал в полученной строке. Если нужно объединить много строк, вам следует подумать об использовании `.join()`, что более эффективно. Вы узнаете о `.join()` немного позже.


Python имеет множество полезных встроенных функций и методов для работы со строками. Например, если вы передадите строку в качестве аргумента функции `len()`, вы получите длину строки или количество содержащихся в ней символов:

len("Happy pythoning!")

Строковый класс (`str`) предоставляет богатый набор методов, полезных для манипулирования и обработки строк. 
`.join()` берет итерацию строк и объединяет их в новую строку. Строка, для которой вы вызываете метод, играет роль разделителя:


" ".join(["Happy", "pythoning!"])

`.upper()` возвращает копию базовой строки со всеми буквами, преобразованными в верхний регистр:

"Happy pythoning!".upper()

`.lower()` возвращает копию базовой строки со всеми буквами, преобразованными в нижний регистр:

"HAPPY PYTHONING!".lower()

`.format()` выполняет операцию форматирования строки. Этот метод обеспечивает большую гибкость при форматировании и интерполяции строк:

name = "John Doe"
age = 25
"My name is {0} and I'm {1} years old".format(name, age)

Вы также можете использовать **f-строку** для форматирования ваших строк без использования `.format()`:

name = "John Doe"
age = 25
f"My name is {name} and I'm {age} years old"

F-строки - это улучшенный синтаксис форматирования строк. Это строковые литералы с буквой f в начале вне кавычек. Выражения, заключенные в фигурные скобки ({}), заменяются своими значениями в форматированной строке.


Строки - это последовательности символов. Это означает, что вы можете извлекать отдельные символы из строки, используя их позиционный индекс. Индекс - это целое число с отсчетом от нуля, связанное с определенной позицией в последовательности:

welcome = "Welcome to Python!"
print(
    welcome[0], 
    welcome[11], 
    welcome[-1], 
    sep='\n'
)

Операция индексации извлекает символ в позиции, указанной данным индексом. Обратите внимание, что отрицательный индекс извлекает элемент в обратном порядке, где -1 является индексом последнего символа в строке.


Вы также можете получить часть строки, разрезав ее:

welcome = "Welcome to Python!"
print(
    welcome[0:7], 
    welcome[11:17], 
    sep='\n'
)

Операция **slice** принимает элемент в форме `[start:end:step]`. Здесь start - это индекс первого элемента, который нужно включить в срез, а end - это индекс последнего элемента, который не включен в возвращаемый срез. Наконец, step - необязательное целое число, представляющее количество элементов, через которые нужно перейти при извлечении элементов из исходной строки. Например, шаг 2 вернет каждый второй элемент между start и end.


## Операции над списками

Списки представляют собой последовательности, подобные строкам, поэтому можно получить доступ к их отдельным элементам, используя целочисленные индексы с отсчетом от нуля:


numbers = [1, 2, 3, 200]
print(
    numbers[0], 
    numbers[1], 
    sep='\n'
)

superheroes = ["batman", "superman", "spiderman"]
print(
    superheroes[-1], 
    superheroes[-2], 
    sep='\n'
)

Вы также можете создавать новые списки из существующего списка, используя операцию `slice`:

numbers = [1, 2, 3, 200]
new_list = numbers[0:3]
new_list

Если вы вложите список, строку или любую другую последовательность в другой список, вы можете получить доступ к внутренним элементам, используя несколько индексов:

mixed_types = ["Hello World", [4, 5, 6], False]
mixed_types[1][2]

Вы также можете объединить свои списки с помощью оператора плюс:

fruits = ["apples", "grapes", "oranges"]
veggies = ["corn", "kale", "mushrooms"]
grocery_list = fruits + veggies
grocery_list

Учитывая список в качестве аргумента, `len()` возвращает длину списка или количество содержащихся в нем объектов:

numbers = [1, 2, 3, 200]
len(numbers)

Наиболее часто используемые методы:

`.append()` принимает объект в качестве аргумента и добавляет его в конец базового списка:


fruits = ["apples", "grapes", "oranges"]
fruits.append("blueberries")
fruits

`.sort()` сортирует базовый список на месте:

fruits.sort()
fruits

`.pop()` принимает в качестве аргумента целочисленный индекс, затем удаляет и возвращает элемент по этому индексу в базовом списке:

numbers_list = [1, 2, 3, 200]
numbers_list.pop(2)

numbers_list

```{warning}
Списки - это довольно распространенные и универсальные структуры данных в Python. Они настолько популярны, что разработчики иногда склонны злоупотреблять ими, что может сделать код неэффективным.
```

## Операции над кортежами

Как и в случае со списками, вы также можете выполнять индексацию и нарезку кортежей:

employee = ("Jane", "Doe", 31, "Software Developer")
employee[0]

employee[1:3]

Поскольку кортежи представляют собой последовательности, вы можете использовать индексы для извлечения определенных элементов в кортежах. Обратите внимание, что вы также можете получить фрагменты из кортежа с помощью операции нарезки.


Вы также можете добавить два кортежа с помощью оператора конкатенации:

first_tuple = (1, 2)
second_tuple = (3, 4)
first_tuple + second_tuple

Операция конкатенации с двумя кортежами создает новый кортеж, содержащий все элементы в двух входных кортежах.


Как и в случае со списками и строками, вы можете использовать некоторые встроенные функции для управления кортежами. Например, `len()` возвращает длину кортежа или количество содержащихся в нем элементов:


numbers = (1, 2, 3)
len(numbers)

С кортежем в качестве аргумента `list()` возвращает список со всеми элементами входного кортежа:

numbers = (1, 2, 3)
list(numbers)

Поскольку кортежи являются неизменяемыми последовательностями, многие методы, доступные для списков, не работают с кортежами. Однако кортежи имеют два встроенных метода:

* `.count()`
* `.index()`

`.count()` принимает объект в качестве аргумента и возвращает количество раз, когда элемент появляется в базовом кортеже. Если объекта нет в кортеже, то `.count()` возвращает 0:

letter = ("a", "b", "b", "c", "a")
letter.count("a")

letter.count("c")

letter.count("d")

`.index()` принимает объект в качестве аргумента и возвращает индекс первого экземпляра этого объекта в имеющемся кортеже. Если объекта нет в кортеже, то `.index()` вызывает `ValueError`:


letter.index("a")

letter.index("c")

letter.index("d")

Кортежи - довольно полезные структуры данных. Они эффективно используют память, неизменяемы и обладают большим потенциалом для управления данными, которые не должны изменяться пользователем. Их также можно использовать в качестве ключей словаря, о чем вы узнаете в следующем разделе.


## Операции над словарями

Вы можете получить значение, связанное с ключом словаря, используя следующий синтаксис:


person1 = {"name": "John Doe", "age": 25, "job": "Python Developer"}
person1["name"]

person1["age"]

Это очень похоже на операцию индексирования, но на этот раз вы используете ключ вместо индекса.


Вы также можете получить ключи, значения и пары ключ-значение в словаре с помощью `.keys()`, `.values()` и `.items()` соответственно:


# Получить все ключи
person1.keys()

# Получить все значения
person1.values()

# Получить все пары ключ-значение
person1.items()

Эти три метода являются фундаментальными инструментами, когда дело доходит до управления словарями в Python, особенно когда вы выполняете итерацию по словарю.


## Операции над множествами

Вы можете использовать некоторые встроенные функции с множествами, как вы это делали с другими встроенными структурами данных. Например, если вы передадите множество в качестве аргумента функции `len(), вы получите количество элементов в множестве:


employees1 = {"John", "Jane", "Linda"}
len(employees1)

Вы также можете использовать операторы для управления множествами в Python. В этом случае большинство операторов представляют собой типичные операции над множеством, такие как объединение (|), пересечение (&), разность (-) и так далее:

primes = {2, 3, 5, 7}
evens = {2, 4, 6, 8}

# Объединение
primes | evens

# Пересечение
primes & evens

# Разница
primes - evens

Множества предоставляют набор методов, в том числе методы, которые выполняют операции с множествами, подобные тем, что в приведенном выше примере. Они также предоставляют методы для изменения или обновления базового множества. 


`.add()` берет объект и добавляет его в множество:

primes = {2, 3, 5, 7}
primes.add(11)
primes

`.remove()` берет объект и удаляет его из множества:

primes = {2, 3, 5, 7, 11}
primes.remove(11)
primes