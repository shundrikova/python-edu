# Functions & Modules

Повторное использование кода - очень важная часть программирования на любом языке. Увеличение размера кода затрудняет поддержку.

```{admonition} Interesting info
:class: tip
Чтобы большой программный проект был успешным, важно придерживаться принципа «**Don't Repeat Yourself**» (Не Повторяйся) или «**DRY**».
```

Мы уже рассмотрели один способ избавиться от повторения кода: с помощью циклов. В этом модуле мы рассмотрим еще два: функции и модули.

## Функции

Любой оператор, состоящий из слова, за которым следует информация в круглых скобках, является вызовом функции.

Вот несколько примеров, которые вы уже видели:

```Python
print('Hello World!')
len([1, 2, 3, 4])
str(12)
```

Слова перед круглыми скобками - это имена функций, а значения, разделенные запятыми внутри круглых скобок, - аргументы функции.

Помимо использования предопределенных функций, вы можете создавать свои собственные функции с помощью оператора `def`.

def my_func():
    print('spam')
    print('spam')
    print('spam')

my_func()

Она не принимает аргументов и трижды печатает «spam». Она определяется, а затем вызывается. Операторы в функции выполняются только при ее вызове.
Блок кода внутри каждой функции начинается с двоеточия (:) и имеет отступ.

Вы должны определить функции до их вызова, точно так же, как вы должны назначать переменные перед их использованием:

hello()

def hello():
    print('hello')

### Аргументы

Все определения функций, которые мы рассмотрели до сих пор, были функциями с нулевыми аргументами, которые вызываются с пустыми круглыми скобками.
Однако большинство функций принимают аргументы.

В приведенном ниже примере определяется функция, которая принимает один аргумент:

def print_with_exclamation(word):
    print(word + '!')

print_with_exclamation('python')

Вы также можете определять функции с более чем одним аргументом; разделите их запятыми:

def print_sum_twice(x, y):
    print(x + y)
    print(x + y)

print_sum_twice(5, 8)

Аргументы функции могут использоваться как переменные внутри определения функции. Однако на них нельзя ссылаться вне определения функции. Это также относится к другим переменным, созданным внутри функции.

def func(variable):
    variable += 1
    print(variable)

func(7)
print(variable)

Технически параметры - это переменные в определении функции, а аргументы - это значения, помещаемые в параметры при вызове функций.

### Return

Некоторые функции, такие как `int` или `str`, возвращают значение, которое можно использовать позже.
Чтобы сделать это для ваших определенных функций, вы можете использовать оператор `return`.

def max(x, y):
    if x >= y:
        return x
    else:
        return y

print(max(4, 7))
z = max(8, 5)
print(z)

Оператор `return` не может использоваться вне определения функции.

Как только вы возвращаете значение из функции, она немедленно перестает выполняться. Никакого кода после оператора возврата никогда не произойдет.

def add_numbers(x, y):
    total = x + y
    return total
    print("This won’t be printed")

print(add_numbers(4, 5))

### Функции как объекты

Хотя они создаются не так, как обычные переменные, функции такие же, как и любые другие значения. Они могут быть назначены и переназначены переменным, а затем на них будут ссылаться эти имена.

def multiply(x, y):
    return x * y

a = 4
b = 7
operation = multiply
print(operation(a, b))

В приведенном выше примере функция умножения назначается переменной `operation`. Теперь `operation` также можно использовать для вызова функции.

Функции также могут использоваться в качестве аргументов других функций.

def add(x, y):
    return x + y

def do_twice(func, x , y):
    return func(func(x, y), func(x, y))

print(do_twice(add, 5, 10))

Как видите, функция `do_twice` принимает функцию в качестве аргумента и вызывает ее в своем теле.

## Лямбды

При обычном создании функции (с использованием `def`) она автоматически присваивается переменной.
Это отличается от создания других объектов, таких как строки и целые числа, которые могут быть созданы «на лету», без присвоения их переменной.

То же самое возможно и с функциями, при условии, что они созданы с использованием лямбда-синтаксиса. Созданные таким образом функции называются анонимными.

Этот подход чаще всего используется при передаче простой функции в качестве аргумента другой функции. Синтаксис показан в следующем примере и состоит из ключевого слова `lambda`, за которым следует список аргументов, двоеточие и выражение.

def my_func(f, arg):
    return f(arg)

my_func(lambda x: 2 * x * x, 5)

```{admonition} Interesting info
:class: tip
Лямбда-функции получили свое название от лямбда-исчисления, которое представляет собой модель вычислений, изобретенную Алонзо Черчем.
```

Лямбда-функции не так мощны, как именованные.
Они могут делать только то, что требует одного выражения - обычно эквивалентно одной строке кода.

# named function
def polynomial(x):
    return x ** 2 + 5 * x + 4
print(polynomial(-4))

# lambda
print((lambda x:  x ** 2 + 5 * x + 4)(-4))

В приведенном выше коде мы на лету создали анонимную функцию и вызвали ее с аргументом.

Лямбда-функции можно назначать переменным и использовать как обычные функции.

double = lambda x: x * 2
print(double(7))

Однако для этого редко есть веская причина - обычно лучше определить функцию с помощью `def`.

## map & filter

Встроенные функции `map` и `filter` - очень полезные функции высшего порядка, которые работают со списками (или подобными объектами, называемыми `iterables`).

`map` принимает функцию и итерацию в качестве аргументов и возвращает новую итерацию с функцией, примененной к каждому аргументу.

def add_five(x):
    return x + 5

nums = [11, 22, 33, 44, 55]
result = list(map(add_five, nums))
print(result)

Мы можем легче достичь того же результата, используя лямбды.

nums = [11, 22, 33, 44, 55]
result = list(map(lambda x: x + 5, nums))
print(result)

Чтобы преобразовать результат в список, мы явно использовали `list`.

`filter` фильтрует итерацию, удаляя элементы, не соответствующие предикату (функция, возвращающая логическое значение).

nums = [11, 22, 33, 44, 55]
result = list(filter(lambda x: x % 2 == 0, nums))
print(result)

Как и `map`, результат должен быть явно преобразован в список, если вы хотите его распечатать.

## Генераторы

**Генераторы** - это тип итераторов, таких как списки или кортежи.
В отличие от списков, они не позволяют индексацию с произвольными индексами, но их все же можно перебирать с помощью циклов `for`.

Их можно создать с помощью функций и оператора `yield`.

def countdown():
    i = 5
    while i > 0:
        yield i
        i -= 1
for i in countdown():
    print(i)

Оператор `yield` используется для определения генератора, заменяя возврат функции для предоставления результата без разрушения локальных переменных.

Из-за того, что они выдают по одному элементу за раз, генераторы не имеют ограничений памяти списков.
На самом деле они могут быть **бесконечными**!

```Python
def infinite_sevens():
    while True:
        yield 7
        
for i in infinite_sevens():
    print(i)
```

Короче говоря, генераторы позволяют объявлять функцию, которая ведет себя как итератор, то есть ее можно использовать в цикле `for`.

Конечные генераторы можно преобразовать в списки, передав их в качестве аргумента функции `list`.

def numbers(x):
    for i in range(x):
        if i % 2 == 0:
            yield i
print(list(numbers(11)))

Использование генераторов приводит к повышению производительности, что является результатом ленивой (по запросу) генерации значений, что приводит к снижению использования памяти. Кроме того, нам не нужно ждать, пока все элементы будут сгенерированы, прежде чем мы начнем их использовать.

## Декораторы

**Декораторы** позволяют изменять функции с помощью других функций.
Это идеально, когда вам нужно расширить функциональность функций, которые вы не хотите изменять.

def decor(func):
    def wrap():
        print('============')
        func()
        print('============')
    return wrap

def print_text():
    print('Hello World!')

decorated = decor(print_text)
decorated()

Мы определили функцию с именем `decor`, которая имеет единственный параметр `func`. Внутри `decor` мы определили вложенную функцию с именем `wrap`. Функция `wrap` напечатает строку, затем вызовет функцию `func()` и напечатает другую строку. Функция `decor` возвращает в качестве результата функцию `wrap`.

Можно сказать, что переменная `decorated` - декорированная версия `print_text` - это `print_text` плюс еще что-то.
Фактически, если бы мы написали полезный декоратор, мы могли бы полностью заменить `print_text` декорированной версией, чтобы мы всегда получали нашу версию `print_text` «плюс что-то».

Это делается путем переназначения переменной, содержащей нашу функцию:

print_text = decor(print_text)
print_text()

Теперь `print_text` соответствует нашей декорированной версии.

В нашем предыдущем примере мы декорировали нашу функцию, заменив переменную, содержащую функцию, на упакованную версию.

Этот шаблон можно использовать в любое время, чтобы обернуть любую функцию.
Python обеспечивает поддержку обертывания функции в декораторе, предварительно добавляя определение функции с именем декоратора и символом `@`.

Если мы определяем функцию, мы можем «декорировать» ее символом `@`, например:

def decor(func):
    def wrap():
        print('============')
        func()
        print('============')
    return wrap

@decor
def print_text():
    print('Hello World!')

print_text()

Одна функция может иметь несколько декораторов.

## Модули

**Модули** - это фрагменты кода, написанные другими людьми для выполнения общих задач, таких как генерация случайных чисел, выполнение математических операций и т. д.

Основной способ использования модуля - это добавить `import module_name` вверху вашего кода, а затем использовать `module_name.var` для доступа к функциям и значениям с именем `var` в модуле.
Например, в следующем примере модуль `random` используется для генерации случайных чисел:

import random

for i in range(5):
    value = random.randint(1, 6)
    print(value)

Код использует функцию `randint`, определенную в модуле `random`, для печати 5 случайных чисел в диапазоне от 1 до 6.

Есть еще один вид импорта, который можно использовать, если вам нужны только определенные функции из модуля.  
Они принимают форму `from module_name import var`, а затем var можно использовать, как если бы он был определен в вашем коде обычным образом.  
Например, чтобы импортировать только константу `pi` из модуля `math`:

from math import pi

print(pi)

Используйте список, разделенный запятыми, для импорта нескольких объектов:

from math import pi, sqrt

`*` импортирует все объекты из модуля. Например: `from math import *`  
Обычно это не рекомендуется, поскольку при этом путают переменные в вашем коде с переменными во внешнем модуле.

Попытка импортировать недоступный модуль вызывает ошибку `ImportError`.

import some_module

Вы можете импортировать модуль или объект под другим именем, используя ключевое слово `as`. Это в основном используется, когда модуль или объект имеет длинное или непонятное имя.

from math import sqrt as square_root

print(square_root(100))

## Стандартная библиотека и pip

В Python есть три основных типа модулей: те, которые вы пишете сами, те, которые вы устанавливаете из внешних источников, и те, которые предустановлены вместе с Python.  
Последний тип называется стандартной библиотекой и содержит множество полезных модулей. Некоторые из полезных модулей стандартной библиотеки включают `string`, `re`, `datetime`, `math`, `random`, `os`, `multiprocessing`, `subprocess`, `socket`, `email`, `json`, `doctest`, `unittest`, `pdb`, `argparse` и `sys`.

Задачи, которые может выполнять стандартная библиотека, включают синтаксический анализ строк, сериализацию данных, тестирование, отладку и управление датами, сообщениями электронной почты, аргументами командной строки и многое другое!

Обширная стандартная библиотека Python - одна из его основных сильных сторон как языка.

Некоторые модули в стандартной библиотеке написаны на Python, а некоторые - на C.  
Большинство из них доступны на всех платформах, но некоторые относятся к Windows или Unix.

Многие сторонние модули Python хранятся в индексе пакетов Python (**PyPI**).  
Лучший способ установить их - использовать программу `pip`. Он устанавливается по умолчанию в современных дистрибутивах Python. Если у вас его нет, его легко установить онлайн. После того, как он у вас есть, установить библиотеки из PyPI очень просто. Найдите имя библиотеки, которую вы хотите установить, перейдите в командную строку и введите `pip install <library_name>`. Как только вы это сделаете, импортируйте библиотеку и используйте ее в своем коде.

Важно вводить команды `pip` в командной строке, а не в интерпретаторе Python.
