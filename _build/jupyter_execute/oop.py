# Object-oriented programming (OOP)

## Классы

Ранее мы рассмотрели две парадигмы программирования - **императивную** (с использованием операторов, циклов и функций в качестве подпрограмм) и **функциональную** (с использованием чистых функций, функций высшего порядка).

Еще одна очень популярная парадигма - **объектно-ориентированное программирование** (ООП).  
Объекты создаются с использованием **классов**, которые на самом деле являются фокусом ООП.
Класс описывает, каким будет объект, но отделен от самого объекта. Другими словами, класс можно описать как план, описание или определение объекта.  
Вы можете использовать один и тот же класс в качестве чертежа для создания нескольких различных объектов.

Классы создаются с использованием ключевого слова **class** и блока с отступом, который содержит **методы класса** (которые являются функциями).
Ниже приведен пример простого класса и его объектов.

class Cat:
    def __init__(self, color, legs):
        self.color = color
        self.legs = legs

felix = Cat("ginger", 4)
rover = Cat("dog-colored", 4)
stumpy = Cat("brown", 3)

Этот код определяет класс с именем `Cat`, который имеет два атрибута: `color` и `legs`.  
Затем класс используется для создания 3-х отдельных объектов этого класса.

### `__init__`

Метод `__init__` - самый важный метод в классе.  
Он вызывается при создании экземпляра (объекта) класса с использованием имени класса в качестве функции.

Все методы должны иметь в качестве первого параметра `self`. Хотя он явно не передается, Python добавляет аргумент `self` в список за вас; вам не нужно включать его при вызове методов. В определении метода `self` относится к экземпляру, вызывающему метод.

Экземпляры класса имеют **атрибуты**, которые представляют собой связанные с ними фрагменты данных.  
В этом примере экземпляры `Cat` имеют атрибуты `color` и `leg`s. К ним можно получить доступ, поставив точку и имя атрибута после экземпляра.  
Таким образом, в методе `__init__` `self.attribute` может использоваться для установки начального значения атрибутов экземпляра.

class Cat:
    def __init__(self, color, legs):
        self.color = color
        self.legs = legs

felix = Cat("ginger", 4)
print(felix.color)

В приведенном выше примере метод `__init__` принимает два аргумента и назначает их атрибутам объекта. Метод `__init__` называется **конструктором класса**.

### Методы 

Классы могут иметь другие **методы**, определенные для добавления к ним функциональности.  
Помните, что все методы должны иметь в качестве первого параметра `self`.  
Доступ к этим методам осуществляется с использованием того же синтаксиса точек, что и для атрибутов.  

class Dog:
    def __init__(self, color, name):
        self.color = color
        self.name = name
        
    def bark(self):
        print('Woof!')

fido = Dog('Fido', 'brown')
print(fido.name)
fido.bark()

Классы также могут иметь **атрибуты класса**, созданные путем присвоения переменных в теле класса. К ним можно получить доступ либо из экземпляров класса, либо из самого класса.

class Dog:
    legs = 4
    def __init__(self, name, color):
        self.name = name
        self.color = color
        
    def bark(self):
        print('Woof!')

fido = Dog('Fido', 'brown')
print(fido.legs)
print(Dog.legs)

Атрибуты класса являются общими для всех экземпляров класса.

Попытка получить доступ к атрибуту экземпляра, который не определен, вызывает ошибку `AttributeError`. Это также происходит, когда вы вызываете неопределенный метод.

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

rect = Rectangle(7, 8)
print(rect.color)

## Наследование

**Наследование** дает возможность разделять функциональные возможности между классами.  
Представьте себе несколько классов: `Cat`, `Dog`, `Rabbit` и так далее. Хотя они могут отличаться в некоторых отношениях (только `Dog` может иметь метод `bark`), они, вероятно, будут похожи в других (все имеют атрибуты `color` и `name`).  
Это сходство может быть выражено, если все они унаследованы от **суперкласса** `Animal`, который содержит общие функции.  
Чтобы унаследовать класс от другого класса, поместите имя суперкласса в круглые скобки после имени класса.

class Animal:
    def __init__(self, name, color):
        self.name = name
        self.color = color
        
class Cat(Animal):
    def purr(self):
        print('Purr...')

class Dog(Animal):
    def bark(self):
        print('Woof!')

fido = Dog('Fido', 'brown')
print(fido.color)
fido.bark()

Класс, который наследуется от другого класса, называется **подклассом**. 
Класс, от которого другой класс унаследован, называется **суперклассом**. 
Если класс наследуется от другого с такими же атрибутами или методами, он переопределяет их.

class Wolf:
    def __init__(self, name, color):
        self.name = name
        self.color = color
    
    def bark(self):
        print('Grr...')

class Dog(Wolf):
    def bark(self):
        print('Woof!')

husky = Dog('Max', 'grey')
husky.bark()

В приведенном выше примере `Wolf` - это суперкласс, `Dog` - подкласс.

Наследование также может быть косвенным. Один класс может наследоваться от другого, и этот класс может наследоваться от третьего класса.

class A:
    def method(self):
        print('A method')

class B(A):
    def another_method(self):
        print('B method')
        
class C(B):
    def third_method(self):
        print('C method')

c = C()
c.method()
c.another_method()
c.third_method()

Однако циклическое наследование невозможно.

Функция `super` - это полезная функция, связанная с наследованием, которая обращается к родительскому классу. Его можно использовать для поиска метода с определенным именем в суперклассе объекта.

class A:
    def spam(self):
        print(1)

class B(A):
    def spam(self):
        print(2)
        super().spam()

B().spam()

`super().spam()` вызывает метод `spam` суперкласса.

## Магические методы (dunders) и перегрузка операторов

**Магические методы** - это специальные методы, у которых в начале и в конце названия есть двойное подчеркивание.
Они также известны как **dunders**.
Пока что мы столкнулись только с `__init__`, но есть и другие.
Они используются для создания функциональности, которую нельзя представить как обычный метод.

Одним из распространенных способов их использования является **перегрузка оператора**.
Это означает определение операторов для пользовательских классов, которые позволяют использовать с ними такие операторы, как `+` и `*`.  

Примером магического метода является `__add__` для `+`.

class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector2D(self.x + other.x, self.y + other.y)

first = Vector2D(5, 7)
second = Vector2D(3, 9)

result = first + second
print(result.x)
print(result.y)

Метод `__add__` позволяет определять настраиваемое поведение для оператора `+` в нашем классе.  
Как видите, он добавляет соответствующие атрибуты объектов и возвращает новый объект, содержащий результат.  
Как только он определен, мы можем добавить два объекта класса вместе.

Дополнительные магические методы для общих операторов:  

`__sub__` для -  

`__mul__` для \*  

`__truediv__` для /  

`__floordiv__` для //  

`__mod__` для %  

`__pow__` для \*\*  

`__and__` для &  

`__xor__` для ^  

`__or__` для |  


Выражение `x + y` переводится в `x.__add__(y)`.  
Однако, если `x` не реализовал `__add__`, а `x` и `y` имеют разные типы, то вызывается `y.__radd__(x)`.  

Для всех только что упомянутых магических методов существуют эквивалентные **r-методы**.

class SpecialString:
    def __init__(self, cont):
        self.cont = cont
    
    def __truediv__(self, other):
        line = '=' * len(other.cont)
        return '\n'.join([self.cont, line, other.cont])
    
spam = SpecialString('spam')
hello = SpecialString('Hello World!')
print(spam / hello)

В приведенном выше примере мы определили **операцию деления** для нашего класса `SpecialString`.

Python также предоставляет магические методы для сравнения.

`__lt__` для <

`__le__` для <=

`__eq__` для ==

`__ne__` для !=

`__gt__` для >

`__ge__` для> =

Если `__ne__` не реализован, он возвращает противоположность `__eq__`.
Других отношений между другими операторами нет.

class SpecialString:
    def __init__(self, cont):
        self.cont = cont
    
    def __gt__(self, other):
        for index in range(len(other.cont) + 1):
            result = other.cont[:index] + '>' + self.cont
            result += '>' + other.cont[index:]
            print(result)
    
spam = SpecialString('spam')
eggs = SpecialString('eggs')
spam > eggs

Как видите, вы можете определить любое настраиваемое поведение для перегруженных операторов.

Есть несколько волшебных способов заставить классы действовать как контейнеры.

`__len__` для `len()`

`__getitem__` для индексации

`__setitem__` для присвоения индексированным значениям

`__delitem__` для удаления индексированных значений

`__iter__` для итерации по объектам (например, в циклах `for`)

`__contains__` для `in`

Есть много других магических методов, которые мы здесь не будем рассматривать, например `__call__` для вызова объектов как функций и `__int__`, `__str__` и т.п. для преобразования объектов во встроенные типы.

import random

class VagueList:
    def __init__(self, cont):
        self.cont = cont
    
    def __getitem__(self, index):
        return self.cont[index + random.randint(-1, 1)]
    
    def __len__(self):
        return random.randint(0, len(self.cont) * 2)

vague_list = VagueList(['A', 'B', 'C', 'D', 'E'])
print(len(vague_list))
print(len(vague_list))
print(vague_list[2])
print(vague_list[2])

Мы переопределили функцию `len()` для класса `VagueList`, чтобы она возвращала случайное число.  
Функция индексации также возвращает случайный элемент в диапазоне из списка на основе выражения.

## Сокрытие данных

Ключевой частью объектно-ориентированного программирования является **инкапсуляция**, которая включает в себя упаковку связанных переменных и функций в один простой в использовании объект - экземпляр класса.  
Связанная концепция - это **скрытие данных**, в котором говорится, что детали реализации класса должны быть скрыты, а для тех, кто хочет использовать этот класс, должен быть представлен чистый стандартный интерфейс.
В других языках программирования это обычно делается с помощью частных методов и атрибутов, которые блокируют внешний доступ к определенным методам и атрибутам в классе.

Философия Python немного отличается. Часто говорят, что «мы все здесь взрослые», что означает, что вы не должны вводить произвольные ограничения на доступ к частям класса. Следовательно, нет способов сделать метод или атрибут строго закрытым.

Однако есть способы отговорить людей от доступа к частям класса, например, указав, что это деталь реализации и что их следует использовать на свой страх и риск.

Слабо закрытые методы и атрибуты имеют в начале **один знак подчеркивания**.  
Это сигнализирует о том, что они являются частными и не должны использоваться внешним кодом. Однако это в основном лишь соглашение и не мешает внешнему коду получить к ним доступ.  
Его единственный фактический эффект заключается в том, что **from module_name import *** не импортирует переменные, которые начинаются с одного символа подчеркивания.

class Queue:
    def __init__(self, contents):
        self._hidden_list = contents
        
    def push(self, value):
        self._hidden_list.insert(0, value)
        
    def pop(self):
        return self._hidden_list.pop(-1)
    
    def __repr__(self):
        return f'Queue({self._hidden_list})'
    
queue = Queue([1, 2, 3])
print(queue)
queue.push(0)
print(queue)
queue.pop()
print(queue)
print(queue._hidden_list)

В приведенном выше коде атрибут `_hiddenlist` помечен как частный, но к нему по-прежнему можно получить доступ во внешнем коде.
Магический метод `__repr__` используется для строкового представления экземпляра.

Сильно закрытые методы и атрибуты имеют **двойное подчеркивание** в начале их имен. Это приводит к искажению их имен, что означает, что к ним нельзя получить доступ извне класса.  
Это делается не для того, чтобы гарантировать их конфиденциальность, а для того, чтобы избежать ошибок, если есть подклассы, у которых есть методы или атрибуты с одинаковыми именами.  
Методы с измененным именем все еще доступны извне, но под другим именем. К методу `__privatemethod` класса `Spam` можно получить доступ извне с помощью `_Spam__privatemethod`.

class Spam:
    __egg = 7
    
    def print_egg(self):
        print(self.__egg)

s = Spam()
s.print_egg()
print(s._Spam__egg)
print(s.__egg)

По сути, Python защищает эти атрибуты, внутренне изменяя их имя - добавляя имя класса.

## Статические методы и методы класса

### Методы класса

Методы объектов, которые мы рассмотрели до сих пор, вызываются экземпляром класса, который затем передается в параметр `self` метода. 
**Методы класса** другие - они вызываются классом, который передается в параметр `cls` метода.  
Обычно их используют фабричные методы, которые создают экземпляр класса, используя параметры, отличные от тех, которые обычно передаются конструктору класса.  
Методы класса отмечены декоратором `classmethod`.

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        
    def calculate_area(self):
        return self.width * self.height
    
    @classmethod
    def new_square(cls, side_length):
        return cls(side_length, side_length)
    
square = Rectangle.new_square(5)
print(square.calculate_area())

`new_square` - это метод класса, который вызывается в классе, а не в экземпляре класса. Он возвращает новый объект класса `cls`.

Технически параметры `self` и `cls` - всего лишь условные обозначения; их можно было поменять на что угодно. Тем не менее, они повсеместно соблюдаются, поэтому разумно их использовать.

### Статические методы

**Статические методы** похожи на методы класса, за исключением того, что они не получают никаких дополнительных аргументов; они идентичны обычным функциям, принадлежащим классу.  
Они отмечены декоратором `staticmethod`.

class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings
        
    @staticmethod
    def validate_topping(topping):
        if topping == 'pineapple':
            raise ValueError('No pineapples!')
        else:
            return True

ingredients = ['cheese', 'onions', 'salami']
if all(Pizza.validate_topping(i) for i in ingredients):
    pizza = Pizza(ingredients)

Статические методы ведут себя как обычные функции, за исключением того факта, что вы можете вызывать их из экземпляра класса.

## Свойства класса

Свойства предоставляют способ настройки доступа к атрибутам экземпляра.  
Они создаются путем помещения декоратора `property` над методом, что означает, что при обращении к атрибуту экземпляра с тем же именем, что и у метода, вместо этого будет вызываться метод.  
Один из распространенных способов использования свойства - сделать атрибут доступным только для чтения.

class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings
        
    @property
    def pineapple_allowed(self):
        return False

pizza = Pizza(['cheese', 'tomato'])
print(pizza.pineapple_allowed)
pizza.pineapple_allowed = True

Свойства также могут быть установлены путем определения функций установки / получения.  
**Сеттер** устанавливает значение соответствующего свойства.  
**Геттер** получает значение.  
Чтобы определить сеттер, вам нужно использовать декоратор с тем же именем, что и свойство, за которым следует точка и ключевое слово **setter**.  
То же самое относится к определению геттера.  

class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings
        self._pineapple_allowed = False
        
    @property
    def pineapple_allowed(self):
        return self._pineapple_allowed
    
    @pineapple_allowed.setter
    def pineapple_allowed(self, value):
        if value:
            password = input('Enter the password: ')
            if password == 'Sw0rdf1sh!':
                self._pineapple_allowed = value
            else:
                raise ValueError('Alert! Intruder!')

pizza = Pizza(['cheese', 'tomato'])
print(pizza.pineapple_allowed)
pizza.pineapple_allowed = True
print(pizza.pineapple_allowed)